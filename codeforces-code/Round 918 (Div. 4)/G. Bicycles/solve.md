# 题解

这题使用了最短路径算法+贪心思路

首先对题目进行初步分析，如果直接从点1开始去找n，会遇到哪些问题有边能不能重复走？
重复走一条边的情况是会出现的，因为自行车的速度导致，完全有可能在路途的一半去隔壁城市换一辆更好的自行车，于是边就会被重复访问，者脱离了我们对常规BFS的认知。

现在我们把重心转移到自行车上，对于自行车的更换，只有可能从更慢的换成更快的，因此为了避免出现去隔壁城市换更好的车，我们先考虑车最好的点。对于从这个点出发，他的车不可能被更换。因为没有更好的车没有必要换。
此时我们就可以计算出，这个点到所有点的最短时间。
经过这个运算我们可以得到`distTo[x]` 代表这个点到x的最短距离。


我们同时设 `ans[s]`代表从s点出发到n点的最短时间。我们这里假设最快的自行车点为s1


接下来考虑第二快的车，此时，第二快的车只有两种情况，去换车到达终点，和不换车到达终点。
所以我们可以发现
`ans[s2] = min(ans[s1] + distTo[s1] * speed, distTo[n] * speed)`
对这两种情况求最小值，便可求出s2到n点的最短时间

对于s3，我们就要考虑是否去s2点和是否去s1点。
代码中体现为
```c++
for(int i = 1; i <= cityNum; i++)
    if(i != s and result[i] != -1)
        result[s] = min(result[s], distTo[i] * speed + result[i]);
```
结果得出后，`result[1]`就是答案

主要在贪心思路和最短路径算法上，可以使用SPFA
Bellman-Ford的队列优化。
