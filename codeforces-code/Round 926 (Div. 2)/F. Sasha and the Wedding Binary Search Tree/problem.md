# F. Sasha and the Wedding Binary Search Tree

萨沙克服了重重困难和艰辛，终于决定与女友结婚。为此，他需要送她一枚订婚戒指。然而，他的女朋友并不喜欢这种浪漫的举动，但她喜欢二叉搜索树 $^{\dagger}$ 。于是，萨沙决定送给她这样一棵树。

在程序员婚礼网站上花了大量时间后，他找到了一棵完美的二叉搜索树，树根位于顶点 $1$ 。在这棵树上，顶点 $v$ 的值等于 $val_v$ 。

但一段时间后，他忘记了一些顶点的值。为了记住找到的树，萨沙想知道，如果已知所有顶点的值都是 $[1, C]$ 段中的整数，他可以在网站上找到多少棵二叉搜索树。因为这个数字可能非常大，所以输出它的模数 $998\,244\,353$ 。

$^{\dagger}$ 二叉搜索树是一棵有根的二叉树，其中任意顶点 $x$ 都具有以下性质：顶点 $x$ 左子树中所有顶点的值（如果存在）都小于或等于顶点 $x$ 的值，顶点 $x$ 右子树中所有顶点的值（如果存在）都大于或等于顶点 $x$ 的值。

**输入**

每个测试由多个测试用例组成。第一行包含一个整数 $t$ ( $1 \le t \le 10^5$ ) - 测试用例的个数。测试用例说明如下。

每个测试用例的第一行包含两个整数 $n$ 和 $C$ （ $2 \leq n \leq 5 \cdot 10^5$ ， $1 \leq C \leq 10^9$ ）--树的顶点数和顶点允许的最大值。

接下来的 $n$ 行描述了树的顶点。第 $i$ 行包含三个整数 $L_i, R_i$ 和 $val_i$ 。( $-1 \le L_i, R_i \le n$ 、 $-1 \le val_i \le C$ 、 $L_i, R_i, val_i \ne 0$ ) - 分别是左侧子节点的编号、右侧子节点的编号和 $i$ \th顶点的值。如果是 $L_i = -1$ ，那么 $i$ /th顶点没有左子。如果是 $R_i = -1$ ，那么 $i$ 个顶点没有右子。如果是 $val_i = -1$ ，那么 $i$ /th顶点的值未知。

可以保证至少存在一棵合适的二叉搜索树。

保证所有测试案例的 $n$ 之和不超过 $5 \cdot 10^5$ 。

**输出**

针对每个测试用例，输出一个整数--适合的二叉搜索树的数量，模数为 $998\,244\,353$ 。

Example
input
```
3
5 5
2 3 -1
-1 -1 2
4 -1 3
-1 5 -1
-1 -1 -1
3 69
2 3 47
-1 -1 13
-1 -1 69
3 3
2 3 -1
-1 -1 -1
-1 -1 -1
```
output
```
4
1
10
```

**注**

在第一个测试案例中，二叉搜索树的形式如下：

![](https://espresso.codeforces.com/64ae70756e14504cad2c408e8861dd59453ee9c0.png)

那么顶点上可能出现的值是： $[2, 2, 3, 2, 2]$ , $[2, 2, 3, 2, 3]$ , $[2, 2, 3, 3, 3]$ 和 $[3, 2, 3, 3, 3]$ ： $[2, 2, 3, 2, 2]$ 、 $[2, 2, 3, 2, 3]$ 、 $[2, 2, 3, 3, 3]$ 和 $[3, 2, 3, 3, 3]$ 。

在第二个测试案例中，所有顶点的值都是已知的，因此只有一棵合适的二叉搜索树。