先需要对问题进行抽象化，对于每个叶子节点，他们一般都是一组或者单个的，如果它们位于一组，说明它们出于同一个子树。
属于同一个子树的条件就是两者的差为1，此时我们便可以让它俩往上一步，看做一个点，这个点就是它们的父节点。转化之后我们可以发现，题目要求还是一样的。因此题目被我们抽象化。

给定一个长度为n的数列，我们定义一个操作。
操作：找到两个相邻的数，他们差为1，删除那个大的数。
问：最后能否只剩下一个0

题目被我们成功抽象化，这道题的主要思路就是贪心，由于有许多的删除元素操作，为了提高效率可以使用链表结构。

贪心思路上来看，每次都删除最大的元素，先查找最大元素的左右是否比它小1，如果是，则删除该元素，同时一定要记得考虑多个相同元素在一起的情况。
若G[x]存储了所有值为x的链表节点指针，则当有G[x]中的某个元素可以被删除，则连续相同一段都可以删除

最后判断链表是否只剩下一个元素0即可。




