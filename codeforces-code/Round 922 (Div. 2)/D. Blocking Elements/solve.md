二分答案 DP

题目简化：从一个数组中挑出几个数，它们的和为m，其它的数因为这几个数分裂成多个区间，每个区间的和分别是m1, m2, m3.... mk。
求max(m, m1, m2, m3, ..., mk)的最小值

这道题的思路是逐步递进的，首先题目求得是最大值的最小值，我们就可以联想到二分答案，去用二分枚举答案，再看枚举的答案是否正确。

解决了第一个问题，此时的题目也被我们转化。已知最大阈值x，求当前这个数组是否能满足这个要求。

也就是问：
能否挑出这样一组数，使得剩下数的多个区间自己的和都不大于x，并且这一组数的和也不超过x。

此时可以把注意力调整到如何挑选这些数，挑选的过程中，被剪切出来的区间和都不会大于x。
如果按照最优方式挑出这些数的和大于x，则不满足，否则，则满足。


此时，按照最基础的想法可能会从头开始计算，一旦区间大于x，就把后面那个数挑选。
但是很容易就可以发现这是错的。

转换思路，往往贪心难以解决，就是DP使用的时候。
我们使用dp[i]表示挑选了第i个数后前i个数被挑选的数和

例如当选择阈值 x = 3
对于序列
arr  1  2  3  4  5
dp 0 1  2  3  6  11

令arr[i]表示arr的第i个数

dp[1] = dp[0] + arr[1]
dp[2] = min(dp[0] + arr[2], dp[1] + arr[2])
dp[3] = min(dp[0] + arr[3], dp[1] + arr[3]， dp[2] + arr[3])

dp[4] = min(dp[2] + arr[4]， dp[3] + arr[4])
注意这里的dp[4]并不能和之前一样，让arr[4]直接加上dp[0]因为区间[1, 3]的和已经大于x了

转移方程也就是
dp[i] = min(dp[j] + arr[i])  ([j + 1, i - 1]区间和不大于x)

不妨我们令arr[n + 1] = 0
dp[n + 1]的值就是有可能不选择最后一个的情况，也就是我们最优状况挑出的一组数的和。

但这样的复杂度依旧可以优化。

已知dp[i]就是arr[i] + 以前的一个符合掉件的dp[j]

如果优先找到了符合条件的 最小dp[j] 就不需要进行多次的比较








