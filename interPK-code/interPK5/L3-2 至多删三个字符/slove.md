分类：动态规划

### 题解

如何从题目上判断这是一道动态规划：

长度为106的字符串明显不能用暴力解决，但是长度较小的时候可以轻松解决。其次，不同的去除方法遇到相同的结果只能算作一种，这再一次否定了暴力的解法，联想到了相同子序列字符串题目，这道题很可能就是一道动态规划，由前面的结果推断后面的结果。

寻找状态转移方程：
关于`dp[i][j]`可以轻松理解为前i的字符中，去掉j个字符的结果。

先不考虑特殊的情况
即所有字符不相同，可得对于前`i`个字符我们可以选择不去掉第`i`个和去掉第`i`个，易得：
`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]`

现考虑特殊的情况
即新添加的字符和尾字符出现重复

比如`abdc c`第一个出现的c我们称为c1，第二个出现的称为c2
此时假如再按照原来的方法就会出现问题（原方法=去c2+保c2）
去c2 包含 保c1 + 去c1
保c2 包含 保c1 + 去c1

问题在于 去c2时 的 保c1 等同于 保c2时 的 去c1（种类数也一样）
此处被重复计算了，我们需要去掉其中的一个，我们也易得：
`保c2去c1 = 去c2保c1 = dp[i - 2][j - 1]`
此时的状态转移为：
`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] - dp[i - 2][j - 1]`

但我们不妨换一个思路
`abd cc`如果新增的是两个c，那么
`dp[i][j] = dp[i - 2][j] + dp[i - 2][j - 1] + dp[i - 2][j - 2]`
分为了，后面两个c去掉0个，去掉1个，去掉2个。

同理，如果新增的是三个c，那么
`dp[i][j] = dp[i - 3][j] + dp[i - 3][j - 1] + dp[i - 3][j - 2]+ dp[i - 3][j - 3]`
分为了，后面两个c去掉0个，去掉1个，去掉2个，去掉3个。

这里需要考虑j和 新增的连续相同字符的个数。

同时可写出优化dp空间(此处的`i`为去掉字符的个数，此时的每次新增都为连续相同的字符合并为一次)
`dp[i] = dp[i] + dp[i - 1] + dp[i - 2] + dp[i - 3]`
至于有几项相加，个数`n = min(新增的字符个数, i)`



