分类：动态规划

## 题解

如何从题目上判断这是一道动态规划：

长度为106的字符串明显不能用暴力解决，但是长度较小的时候可以轻松解决。其次，不同的去除方法遇到相同的结果只能算作一种，这再一次否定了暴力的解法，联想到了相同子序列字符串题目，这道题很可能就是一道动态规划，由前面的结果推断后面的结果。

寻找状态转移方程：
关于`dp[i][j]`可以轻松理解为前i的字符中，去掉j个字符的结果。

### 先不考虑特殊的情况
即所有字符不相同，可得对于前`i`个字符我们可以选择不去掉第`i`个和去掉第`i`个，易得：
`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]`

### 现考虑特殊的情况

### 一开始的错误理解：
即新添加的字符和尾字符出现重复

比如`abdc c`第一个出现的c我们称为c1，第二个出现的称为c2
此时假如再按照原来的方法就会出现问题（原方法=去c2+保c2）
去c2 包含 保c1 + 去c1
保c2 包含 保c1 + 去c1

问题在于 去c2时 的 保c1 等同于 保c2时 的 去c1（种类数也一样）
此处被重复计算了，我们需要去掉其中的一个，我们也易得：
`保c2去c1 = 去c2保c1 = dp[i - 2][j - 1]`
此时的状态转移为：
`dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] - dp[i - 2][j - 1]`

但我们不妨换一个思路
`abd cc`如果新增的是两个c，那么
`dp[i][j] = dp[i - 2][j] + dp[i - 2][j - 1] + dp[i - 2][j - 2]`
分为了，后面两个c去掉0个，去掉1个，去掉2个。

同理，如果新增的是三个c，那么
`dp[i][j] = dp[i - 3][j] + dp[i - 3][j - 1] + dp[i - 3][j - 2]+ dp[i - 3][j - 3]`
分为了，后面两个c去掉0个，去掉1个，去掉2个，去掉3个。

这里需要考虑j和 新增的连续相同字符的个数。

同时可写出优化dp空间(此处的`i`为去掉字符的个数，此时的每次新增都为连续相同的字符合并为一次)
`dp[i] = dp[i] + dp[i - 1] + dp[i - 2] + dp[i - 3]`
至于有几项相加，个数`n = min(新增的字符个数, i)`

### 正解：

但是这并不能得到正解，当我们再次考虑`abab`时，即可发现，去掉前两个和去掉后两个的结果是一样的，然而上面的解法却让他等同于`abcd`，我们需要重新考虑特殊情况的真正含义。

`abcdef e`和`abcdef g`两者是不同的，前者去掉`ef`和去掉`fe`是一样的，至于发生的原因是因为最后一个`e`可以替代前一个`e`，替代时即删除两个`e`之间的字符再删去任意一个e。
按照错误理解来看就是删除字符之后两边合并导致出现了多个字符连续，此时的删除就需要考虑减去重复计算。

所以对于任意一个新增字符，要考虑的是此时的删除是否会导致新的连续字符出现。如果出现，就需要减去这个情况的个数。

进行举例
`qweabc b`
此时的新`b`我们称为`b2`，旧`b`称为`b1`。
当出现`b2`代替`b1`的情况，就是我们重复计算了的情况。
去b2 = 保b1 + 去b1
保b2 = 保b1 + 去b1
去掉`c`的情况下 `去b2 保b1 = 保b2 去b1`
此时去掉这个情况即可。
需要去掉多余情况的条件是，当要删去j个字符，在尾巴的j个字符中，有出现和新增字符相同的字符。
```c++
for(int k = i - 1;k>=1 and i - k<=j; k--)
{
    if(input[i - 1] == input[k - 1])
    {
        dp[i][j] -= dp[k - 1][j - (i - k)];
        break;
    }
}
```
以上即为删除情况

按照此思路即可AC



