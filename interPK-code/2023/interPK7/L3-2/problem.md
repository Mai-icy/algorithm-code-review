L3-2 完美树
给定一棵有 *N* 个结点的树（树中结点从 1 到 *N* 编号，根结点编号为 1）。每个结点有一种颜色，或为黑，或为白。

称以结点 *u* 为根的子树是 **好的**，若子树中黑色结点与白色结点的数量之差的绝对值不超过 1。称整棵树是 **完美树**，若对于所有 1 ≤ *i* ≤ *N*，以结点 *i* 为根的子树都是好的。

你需要将整棵树变成完美树，为此你可以进行以下操作任意次（包括零次）：选择任意一个结点 *i* (1 ≤ *i* ≤ *N*)，改变结点 *i* 的颜色（若结点 *i* 目前是黑色则将其改为白色，若结点 *i* 目前是白色则将其改为黑色）。这次操作的代价为 *P**i*。

求将给定的树变为完美树的最小代价。

注：以结点 *i* 为根的子树，由结点 *i* 以及结点 *i* 的所有后代结点组成。

### 输入格式:

输入第一行为一个数 *N* (1≤*N*≤105)，表示树的结点个数。

接下来的 *N* 行，第 *i* 行的前三个数为 *C**i*,*P**i*,*K**i* (1≤*P**i*≤104,0≤*K**i*≤*N*)，分别表示树上编号为 *i* 的结点的初始颜色（0 为白色，1 为黑色）、变换颜色的代价及孩子结点的数量。紧跟着有 *K**i* 个数，为孩子结点的编号。数字均用一个空格隔开，所有的编号保证在 1 到 *N* 里，且不会有环。

数据中只包含一棵树。

### 输出格式:

输出一行一个数，表示将树 *T* 变为完美树的最小代价。

### 输入样例:

```in
10
1 100 3 2 3 4
0 20 1 7
0 5 2 5 6
0 8 1 10
0 7 0
0 2 0
1 1 2 8 9
0 15 0
0 13 0
1 8 0
```

### 输出样例:

```out
15
```

### 提示:

样例中最佳的方案是：将 9 号点和 6 号点从白色变为黑色，此时代价为 13 + 2 = 15。